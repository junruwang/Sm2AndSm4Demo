#include <jni.h>
#include <stdio.h>
#include <stdlib.h>
#include <syslog.h>

#include <sys/resource.h>
#include <sys/stat.h>
#include <unistd.h>
#include <string.h>
#include <fcntl.h>
#include <sys/ioctl.h>
#include <sys/inotify.h>
#include <sys/limits.h>
#include <sys/poll.h>
#include "android/log.h"
#include <errno.h>

#define proc_ctrl_name  "/proc/driver/secsigncmd"
#define proc_cursor_name  "/proc/driver/secsigncursor"
//#define POLLIN 0x0001

int fd;
int fd_cursor;
static int num=0;
static int readCursor=0;
#define u8 unsigned char
#define u16 unsigned int
u16 GetCRC16(u8* pchMsg, u16 wDataLen);
int genSM2PairFromJNI();
int getSM2PubFromJNI(unsigned char* sm2Pub);
int setMainKeyFromJNI(unsigned char *mainkey);
int setWorkKeyFromJNI(unsigned char *signKey);

int getcursor(void);
unsigned char sm2Pub_text[120]={0x3C,0xFD,0x03,0x10,0x1A,0x67,0x51,0x38,0xDC,0xFB,0x6C,0x0C,0xB6,0x1F,0x2C,0x5D,0x3E,0x8C,0x7F,0x6D,0xE4,0xB9,0xAD,0x87,0x53,0xFA,0x65,0x8A,0x28,0x97,0xE9,0x73,0x59,0x20,0xCF,0x6C,0x03,0x15,0xFE,0xE6,0x38,0x50,0xAC,0x18,0xAB,0x94,0xDD,0x9A,0x28,0xEE,0x5E,0xCA,0xB4,0xD2,0x3B,0x6E,0xEB,0x2F,0x1D,0xB4,0x3B,0x65,0x29,0xC7,0x19,0xDC,0xBD,0xA8,0xC8,0xFC,0x2D,0x59,0x00,0x60,0x29,0x00,0x4F,0x7A,0xDD,0xB5,0xA4,0xBD,0xE1,0x1E,0x41,0x3D,0xA5,0xF1,0x07,0x35,0xC1,0x53,0x77,0x74,0x5F,0xD0,0x01,0x42,0xE3,0x86,0x89,0xD3,0x2C,0x2F,0xD7,0xF1,0xF6,0xD0,0x14,0xCF,0xD4,0x4B};


unsigned char sm2Pub_text2[112]={0x04,0xF1,0x69,0x37,0x0F,0xD6,0x19,0x32,0xD3,0x9F,0x9F,0x51,0xED,0xF8,0x71,0xCD,0x7D,0xB9,0x70,0x19,0x54,0x06,0x3D,0xE1,0x26,0x96,0x24,0x52,0x1C,0x7B,0xBA,0xF1,0x1B,0x10,0xAC,0x18,0xAB,0x94,0xDD,0x9A,0x28,0xEE,0x5E,0xCA,0xB4,0xD2,0x3B,0x6E,0xEB,0x2F,0x1D,0xB4,0x3B,0x65,0x29,0xC7,0x19,0xDC,0xBD,0xA8,0xC8,0xFC,0x2D,0x59,0x00,0x60,0x29,0x00,0x4F,0x7A,0xDD,0xB5,0xA4,0xBD,0xE1,0x1E,0x41,0x3D,0xA5,0xF1,0x07,0x35,0xC1,0x53,0x77,0x74,0x5F,0xD0,0x01,0x42,0xE3,0x86,0x89,0xD3,0x2C,0x2F,0xD7,0xF1,0xF6,0xD0,0x14,0xCF,0xD4,0x4B};


unsigned char sm2Pub_text3[135]={};
unsigned char mainkey[16]={0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11};
unsigned char workkey[16]={0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55};
struct pollfd fds_cursor;

static const char *TAG12="smExec";
#define LOGD(fmt, args...) __android_log_print(ANDROID_LOG_DEBUG, TAG12, fmt, ##args)

unsigned char sm2_pubkey[64]={0};

JNIEnv* thisEnv;
jobject* smObj;


/**
 * 开端口
 * 成功返回0，失败返回-1
 */
JNIEXPORT jint JNICALL Java_android_sm_api_SmExec_open
        (JNIEnv *env, jobject obj){
    thisEnv = env;
    smObj = obj;
    if ((fd = open(proc_ctrl_name,O_RDWR)) < 0) {
        LOGD("open fd error!\n");
        return -1;
    }
    return 0;
}

/**
 * 生成SM2密钥对
 * 成功返回0，失败返回-1
 */
JNIEXPORT jint JNICALL Java_android_sm_api_SmExec_genSM2PairFromJNI
        (JNIEnv *env, jobject obj){
    thisEnv = env;
    smObj = obj;
    int ret=0;
    int crcvalue=0;
    int i=28;
    unsigned char buf[30]={0};

    buf[0]=0xFA;
    buf[1]=0xC0;
    buf[2]=0x00;
    buf[3]=0x18;
    buf[4]=0x00;
    crcvalue=GetCRC16(buf,28);
    buf[28]=(crcvalue>>8)&0xFF;
    buf[29]=(unsigned char)crcvalue&0x00FF;

    ret=write(fd,buf,30);
    memset(buf,30,0);

    ret=read(fd,buf,30);
    if(ret<=0){
        return -1;
    }

    return 0;
}

/**
 * 获取SM2公钥
 */
JNIEXPORT jbyteArray JNICALL Java_android_sm_api_SmExec_getSM2PubFromJNI
        (JNIEnv *env, jobject obj){
    thisEnv = env;
    smObj = obj;
	int ret=0;
	int crcvalue=0;
	int i=0;
    int j=0;
    unsigned char buf[30]={0};
	unsigned char buf_temp[128]={0};
	unsigned char data_offset=0;
	unsigned char len=0;

	buf[0]=0xFA;

	buf[3]=0x18;
	buf[4]=0x01;

	unsigned char packet_max=(64/23)+1;
	for (i = 0; i < packet_max; ++i)
	{
		if (i==(packet_max-1))
		{
			buf[1]=(0xC0)|(64%23);
			buf[2]=0xFF;
		}
		else
			{
			buf[2]=(i+1);//len
			buf[1]=(0xC0)|(0x17);
		}

		crcvalue=GetCRC16(buf, 26);
		buf[28]=(crcvalue>>8)&0xFF;
		buf[29]=(unsigned char)crcvalue&0x00FF;

		ret=write(fd, buf, 30);
		ret=read(fd, buf_temp, 30);
		len=buf_temp[1]&0x1F;

		memcpy(sm2_pubkey+data_offset, buf_temp+5, len-3);
		LOGD("setMainKey:len>>> [%d]",len);

		data_offset+=(len-3);
    }

    //转byte数组
    jbyteArray array=(*thisEnv)->NewByteArray(thisEnv,sizeof(sm2_pubkey));
    (*thisEnv)->SetByteArrayRegion(thisEnv,array,0,sizeof(sm2_pubkey),sm2_pubkey);
    return array;


}

/**
 * 设置主密钥
 * 成功返回0，获取加密数据失败返回-1，设置主密钥失败返回-2
 */
JNIEXPORT jint JNICALL Java_android_sm_api_SmExec_setMainKeyFromJNI
        (JNIEnv *env, jobject obj, jbyteArray byteArray){
    thisEnv = env;
    smObj = obj;

    int ret=0;
    int crcvalue=0;
    int i=0;
    int len=0;
    unsigned char buf[30]={0};
    unsigned char buf2[30]={0};
    unsigned char buf_text[30]={0};
    unsigned char sm2PubKey[112]={0};

    unsigned char* sm2PubText=( char*)(*thisEnv)->GetByteArrayElements(thisEnv,byteArray,0);
    if(sm2PubText==NULL){
        return -1;
    }
    memcpy(sm2PubKey,sm2PubText,112);

    buf[0]=0xFA;
    buf[1]=0xC0;

    //buf[2]=0x04;//len include the cmd1 cmd2 packet_H packet_L
    buf[3]=0x18;
    buf[4]=0x02;
    unsigned char packet_max=5;//(112/23)+1;
    for (i = 0; i < packet_max; i++)
    {
        if(i==(packet_max-1))
        {
            buf[1]=(0xC0)|(112%23);
            buf[2]=0xFF;
            len=112%23;
        }

        else
        {
            buf[1]=(0xC0)|(0x17);
            buf[2]=(i+1);//
            len=23;
		}

		memcpy(buf+5,sm2PubKey+(i*23),len);
		crcvalue=GetCRC16(buf,28);
		buf[28]=(crcvalue>>8)&0xFF;
		buf[29]=(unsigned char)crcvalue&0x00FF;

		ret=write(fd,buf,30);
		memset(buf,30,0);
		ret=read(fd,sm2PubText,30);
    }
    if(sm2PubText[5]!=0){
        (*thisEnv)->ReleaseByteArrayElements(thisEnv,byteArray,sm2PubText,0);
        return -2;
    }
    (*thisEnv)->ReleaseByteArrayElements(thisEnv,byteArray,sm2PubText,0);
    return 0;
}

/**
 * 设置工作密钥
 * 成功返回0，获取加密数据失败返回-1，设置工作密钥失败返回-2
 */
JNIEXPORT jint JNICALL Java_android_sm_api_SmExec_setWorkKeyFromJNI
        (JNIEnv *env, jobject obj, jbyteArray byteArray){
    thisEnv = env;
    smObj = obj;
    unsigned char workKey[16]={0};

    unsigned char* sm4workKey=( char*)(*thisEnv)->GetByteArrayElements(thisEnv,byteArray,0);
    if(sm4workKey==NULL){
        return -1;
    }
    memcpy(workKey,sm4workKey,16);

    int ret=0;
    int crcvalue=0;
    int i=30;
    unsigned char buf[30]={0};
    unsigned char work_key[16]={0xF1,0xFE,0x95,0xF4,0x07,0x56,0x66,0x9E,0x62,0x5F,0x18,0x21,0x06,0x1A,0x8A,0xB8};
    buf[0]=0xFA;
    buf[1]=(0xC0|0x10);

    //buf[2]=0x04;//len include the cmd1 cmd2 packet_H packet_L
    buf[3]=0x18;
    buf[4]=0x03;

    memcpy(buf+5,workKey,16);
    crcvalue=GetCRC16(buf,28);
    buf[28]=(crcvalue>>8)&0xFF;
    buf[29]=(unsigned char)crcvalue&0x00FF;

    ret=write(fd,buf,30);
    memset(buf,30,0);
    ret=read(fd,buf,30);
    if(buf[5]!=0){
        (*thisEnv)->ReleaseByteArrayElements(thisEnv,byteArray,sm4workKey,0);
        return -2;
    }
    (*thisEnv)->ReleaseByteArrayElements(thisEnv,byteArray,sm4workKey,0);
    return 0;

}

JNIEXPORT jint JNICALL Java_android_sm_api_SmExec_vertifyKeyFromJNI
        (JNIEnv *env, jobject obj, jint i, jstring str){

}

/**
 * 打开Cursor端口
 * 成功返回0，失败返回-1
 */
JNIEXPORT jint JNICALL Java_android_sm_api_SmExec_openCursor
(JNIEnv *env, jobject obj){
    if ((fd_cursor = open(proc_cursor_name, O_RDWR)) < 0) {
        printf("open cursor error!\n");
        exit(1);
        return -1;
    }
    fds_cursor.fd=fd_cursor;
        fds_cursor.events=POLLIN;
    return 0;

}

/**
 * 获取光标信息
 *
 */
JNIEXPORT jbyteArray JNICALL Java_android_sm_api_SmExec_getCursor
    (JNIEnv *env, jobject obj){
    thisEnv = env;
        smObj = obj;
    int ret=0;
    int crcvalue=0;
    int len=0;
    int MAX_LEN=4096;
    int j=0,a=-3;
    unsigned char buf[30]={ 0 };
    unsigned char buf_temp[4096]={0};
    unsigned char buf_temp2[4096]={0};
    readCursor=1;
    while(readCursor){
        if(poll(&fds_cursor, 1, 5000)>0){
            if (a=(fds_cursor.revents&POLLIN)){
                ret=read(fds_cursor.fd, buf, 30);
                memcpy( buf_temp+len, buf+12, 16);
                len+=16;
                memset(buf, 30, 0);
                j++;
                if (j>=(MAX_LEN/16)){
                    break;
                    }

            }
        }
    }
    //close(fds_cursor.fd);
        jbyteArray array=(*env)->NewByteArray(env, 16*j);
        (*env)->SetByteArrayRegion(env, array, 0, 16*j, buf_temp);
                num++;
                    return array;

}

/**
 * 设置是否允许读取光标信息
 * 返回读取光标状态位，1为读取，0为不读取
 */
JNIEXPORT jint JNICALL Java_android_sm_api_SmExec_allowGetCursor
    (JNIEnv *env, jobject obj,jint mode){
    thisEnv = env;
    smObj = obj;
    if(mode==1){
        readCursor=1;
    }else{
        readCursor=0;
    }
    return readCursor;
}


u8  chCRCHTalbe[]={
        0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
        0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
        0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
        0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
        0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
        0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
        0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
        0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
        0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
        0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
        0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
        0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
        0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
        0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
        0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
        0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
        0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
        0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
        0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
        0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
        0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
        0x00, 0xC1, 0x81, 0x40};

u8 chCRCLTalbe[] = {
        0x00, 0xC0, 0xC1, 0x01, 0xC3, 0x03, 0x02, 0xC2, 0xC6, 0x06, 0x07, 0xC7,
        0x05, 0xC5, 0xC4, 0x04, 0xCC, 0x0C, 0x0D, 0xCD, 0x0F, 0xCF, 0xCE, 0x0E,
        0x0A, 0xCA, 0xCB, 0x0B, 0xC9, 0x09, 0x08, 0xC8, 0xD8, 0x18, 0x19, 0xD9,
        0x1B, 0xDB, 0xDA, 0x1A, 0x1E, 0xDE, 0xDF, 0x1F, 0xDD, 0x1D, 0x1C, 0xDC,
        0x14, 0xD4, 0xD5, 0x15, 0xD7, 0x17, 0x16, 0xD6, 0xD2, 0x12, 0x13, 0xD3,
        0x11, 0xD1, 0xD0, 0x10, 0xF0, 0x30, 0x31, 0xF1, 0x33, 0xF3, 0xF2, 0x32,
        0x36, 0xF6, 0xF7, 0x37, 0xF5, 0x35, 0x34, 0xF4, 0x3C, 0xFC, 0xFD, 0x3D,
        0xFF, 0x3F, 0x3E, 0xFE, 0xFA, 0x3A, 0x3B, 0xFB, 0x39, 0xF9, 0xF8, 0x38,
        0x28, 0xE8, 0xE9, 0x29, 0xEB, 0x2B, 0x2A, 0xEA, 0xEE, 0x2E, 0x2F, 0xEF,
        0x2D, 0xED, 0xEC, 0x2C, 0xE4, 0x24, 0x25, 0xE5, 0x27, 0xE7, 0xE6, 0x26,
        0x22, 0xE2, 0xE3, 0x23, 0xE1, 0x21, 0x20, 0xE0, 0xA0, 0x60, 0x61, 0xA1,
        0x63, 0xA3, 0xA2, 0x62, 0x66, 0xA6, 0xA7, 0x67, 0xA5, 0x65, 0x64, 0xA4,
        0x6C, 0xAC, 0xAD, 0x6D, 0xAF, 0x6F, 0x6E, 0xAE, 0xAA, 0x6A, 0x6B, 0xAB,
        0x69, 0xA9, 0xA8, 0x68, 0x78, 0xB8, 0xB9, 0x79, 0xBB, 0x7B, 0x7A, 0xBA,
        0xBE, 0x7E, 0x7F, 0xBF, 0x7D, 0xBD, 0xBC, 0x7C, 0xB4, 0x74, 0x75, 0xB5,
        0x77, 0xB7, 0xB6, 0x76, 0x72, 0xB2, 0xB3, 0x73, 0xB1, 0x71, 0x70, 0xB0,
        0x50, 0x90, 0x91, 0x51, 0x93, 0x53, 0x52, 0x92, 0x96, 0x56, 0x57, 0x97,
        0x55, 0x95, 0x94, 0x54, 0x9C, 0x5C, 0x5D, 0x9D, 0x5F, 0x9F, 0x9E, 0x5E,
        0x5A, 0x9A, 0x9B, 0x5B, 0x99, 0x59, 0x58, 0x98, 0x88, 0x48, 0x49, 0x89,
        0x4B, 0x8B, 0x8A, 0x4A, 0x4E, 0x8E, 0x8F, 0x4F, 0x8D, 0x4D, 0x4C, 0x8C,
        0x44, 0x84, 0x85, 0x45, 0x87, 0x47, 0x46, 0x86, 0x82, 0x42, 0x43, 0x83,
        0x41, 0x81, 0x80, 0x40};


u16 GetCRC16(u8* pchMsg, u16 wDataLen)
{
    u8 chCRCHi = 0xFF; // ??CRC×??ú3?ê??ˉ
    u8 chCRCLo = 0xFF; // μíCRC×??ú3?ê??ˉ
    u16 wIndex;         // CRC?-?·?Dμ??÷òy
    while (wDataLen--)
    {
        // ????CRC
        wIndex = chCRCLo ^ *pchMsg++ ;
        chCRCLo = chCRCHi ^ chCRCHTalbe[wIndex];
        chCRCHi = chCRCLTalbe[wIndex] ;
    }
    return ((chCRCHi << 8) | chCRCLo) ;
}




